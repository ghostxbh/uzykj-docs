---
title: 过期淘汰策略
date: 2021-01-11
sidebar: 'auto'
categories:
  - Database
tags:
  - Redis
  - 过期淘汰策略
author: ghostxbh
location: blog
summary: 如果假设你设置一个一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？
---
# 过期淘汰策略

## 1、Redis的过期key删除策略有哪些？也是expire原理

如果假设你设置一个一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？
答案是：定期删除+惰性删除

- 定期删除

> 定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms**随机抽取**一些key来检查和删除的。

- 惰性删除

> 定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。
> 并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下

通过上述两种手段结合起来，保证过期的key一定会被干掉

- 总结

> 很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉

但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？

答案是：走内存淘汰机制。

## 2、Redis淘汰策略有哪些？

如果redis的内存占用过多的时候，此时会进行内存淘汰策略：
假设如下场景：

```
redis里有10000个key，现在已经满了，redis需要触发内存淘汰策略删除key
1个key，最近1min被查了2w次
1个key，最近10min被查了100次
1个key，最近1小时被查了10次
```

- noeviction：当内存不足以写新数据的时候，那么写操作会报错。（一般没人用，毕竟只是缓存，又不是mysql这种ACID的关系型数据库）
- allkeys-lru：当内存不足以写新数据的时候，在key空间中，移除最近最少使用的key（这个是最常用的），如果只移除一个的话，那么最后一个key肯定被移除
- allkeys-random：当内存不足以写新数据的时候，在key空间中，随机移除某个key（一般没人用，万一把我活跃的key移除了咋办）
- volatile-lru：当内存不足以写新数据的时候，在设置了过期时间的key中，移除最近最少使用的key（这个也还凑合，但是也不咋地，都设置过期时间了，你还给我移除干嘛）
- volatile-random：当内存不足以写新数据的时候，在设置了过期时间的键空间中，随机移除某个key（极其不合适，还不如allkeys-random）
- volatile-ttl：当内存不足以写新数据的时候，在设置了过期时间的键空间中，有更早过期时间的key优先移除（也不咋合适，不一定更早过期的就是不活跃key，而且都快过期了你还给我移除干嘛，自生自灭）
- Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。

总结：**Redis的内存淘汰策略的选取并不会影响过期的key的处理，而是用于处理内存不足时需要申请额外空间的数据，过期策略用于处理过期的缓存数据。**

## 资料
- [Redis 内存淘汰机制详解](https://www.cnblogs.com/songjilong/p/14453051.html)

---
收录时间: 2021-01-11

<Vssue :title="$title" />
