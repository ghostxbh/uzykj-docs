---
title: MySQL索引
date: 2021-01-19
sidebar: 'auto'
categories:
  - Database
tags:
  - MySQL
  - 索引
author: ghostxbh
location: blog
summary: MySQL索引介绍、使用、数据结构，应用场景。
---
# 索引

## 介绍
**索引**是帮助`MySQL`高效获取数据的排好序的数据结构

### 聚簇索引
也译作聚集索引，它将数据存储与索引放到了一块，找到索引也就找到了数据

### 非聚簇索引
也译作非聚集索引，它将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，`myisam`通过`key_buffer`把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在`key buffer`命中时，速度慢的原因

## 索引数据结构
- 二叉树
- 红黑树
- Hash表
- B-Tree

## 1、列举一些导致索引失效的场景

- 查询条件包含or导致后面的索引失效
- like左模糊
- 字符串类型没加单引号
- 联合索引，查询时的条件列不是联合索引中的第一个列
- 在索引列上使用mysql的内置函数
- 对索引列运算（如，+、-、*、/）
- 索引字段上使用！= 或者 < >，not in
- 发生隐式类型转换会导致索引失效
- mysql估计使用全表扫描要比使用索引快,则不使用索引。这个是mysql自己决定的，发现后我们可以使用强制索引的语法让MySQL强制走索引

## 2、索引不适合哪些场景？

- 表里数据量很少
- 更新频繁的字段
- 区分度很低的字段

## 3、为什么用B+树而不是B树或二叉树或平衡二叉树？

**为什么不是一般二叉树？**

如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

**为什么不是平衡二叉树呢？**

我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来了，查询效率就快了。

**那为什么不是B树而是B+树呢？**

1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。

2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。

## 4、聚簇索引与非聚簇索引的区别

- 聚簇索引：索引的叶节点就是数据节点。所以不需要回表。主键id就是聚簇索引，有且仅有一个。 
- 非聚簇索引：叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。要想更多的数据需要回表查，可以有多个非聚簇索引。

## 5、如何写sql能够有效的使用到复合索引？

确保最左匹配原则有效。

## 6、Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？

- B+树可以范围查询，Hash不行
- B+树可以复合索引的最左侧原则，Hash不行
- B+树可以支持order by排序，Hash不行
- B+树在等值查询上的效率不如Hash
- B+树支持右模糊查询走索引，hash索引根本无法进行模糊查询

## 7、索引有哪几种类型？

- 主键索引：也是聚簇索引，一张表只能有一个 ，不允许为null且唯一，查询的时候不需要回表。
- 唯一索引：不允许为null且唯一。一张表可以有多个。
- 普通索引：普通索引。
- 全文索引：全文检索用，对文本内容进行分词搜索。
- 覆盖索引：select的字段正好是索引字段，这时候不需要回表操作。
- 组合索引：多个列值组成一个索引，使用的时候要遵循最左匹配原则。

## 8、创建索引有什么原则呢？

- 最左前缀匹配
- 频繁作为查询条件的字段
- 频繁更新的字段不适合
- 索引列不能参与计算和使用一些函数
- 优先考虑索引组合，而不是每次都新建索引
- 在order by或group by字句中，使用索引要遵循最左前缀匹配
- 区分度低的列不适合
- 大数据类型的列不适合（比如text等）

## 9、什么是最左前缀原则？什么是最左匹配原则？

就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。比如有组合索引（a,b），那么使用的时候只写where b = xxx会导致索引失效，因为a在前面丢了，但是写成这样where b = x and  a  = x;这样索引是可以生效的，因为优化器阶段会给优化成where a = x and b = x，不会让索引失效。

## 10、覆盖索引、回表等这些，了解过吗？

- 覆盖索引：查询列就是所使用的索引列，这样不需要回表查询。
- 回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。

## 11、使用索引查询一定能提高查询的性能吗？为什么？

通常情况下是可以的，但是也有特例，比如你在区分度不高的字段上使用索引（比如性别），那就未必能提升性能，因为索引也需要物理存储空间的。

## 12、count(1)、count(*) 与 count(列名) 的区别？

- count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL
- count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL
- count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。

效率上MySQL对count(*)做过优化， count(1)≈count(\*)>count(列名) 

## 13、列值为NULL时，查询是否会用到索引？

列值为NULL也是可以走索引的。但是执行计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度。

## 14、非聚簇索引的查询都需要回表吗？

不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询，比如覆盖索引。

## 15、什么是索引下推？

MySQL5.6新做的优化。索引下推可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，比如：

```mysql
-- (name,is_del)是组合索引
select * from t_user where name like '张%' and is_del=1;
```

在MySQL 5.6之前，只能从匹配的位置一个个回表。到主键索引上找出数据行，再对比字段值是不是张开头且is_del=1。

在MySQL 5.6之后，索引下推可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，也就是回表查询的时候只回表查询有效结果集，也就是姓张的且is_del=1的这些数据进行回表，简单来说就是先过滤好需要的结果，然后去回表查询全部字段。

## 16、频繁更新索引字段可以吗？为什么？

可以但不推荐，因为每个索引都是一棵B+树，是按照大小排序的，更新索引字段的话可能会造成多个数据页的数据之间挪动。

## 17、为什么group by 和 order by会使查询变慢

group by 和 order by操作通常需要创建一个临时表来处理查询的结果，所以如果查询结果很多的话会严重影响性能。

## 18、怎么优化order by？

order by 里的字段可以组合索引，但是要么都加升序要么都加降序，不能部分字段升序，部分字段降序，这样走不了索引。

## 19、怎么优化group by？

遵循最左前缀匹配就行。

## 20、从innodb的索引结构分析，为什么索引的key长度不能太长？

key 太长会导致一个页当中能够存放的key的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率。


> [MySQL索引总结](https://zhuanlan.zhihu.com/p/29118331)

> [深入理解 MySQL 索引](https://www.infoq.cn/article/ojkwyykjoyc2ygb0sj2c)

> [MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)


---
收录时间: 2021-01-19

<Vssue :title="$title" />
