---
title: MySQL基础与日志
date: 2021-01-05
tags:
    - MySQL
    - BufferPool
    - redolog
    - binlog
author: 编程界的小学生
location: Gitee
summary: MySQL基础、架构、日志相关介绍。
---
# 基础与日志

## 1、一个查询语句是怎么执行的？

> 查询缓存弊大于利，因为更新操作会让缓存失效，所以MySQL8.0将此部分彻底移除了。

![select](http://file.uzykj.com/mysql_1.png)

## 2、一条更新语句是怎么执行的？

![update](http://file.uzykj.com/e748d07d-fcf2-3a67-9b6c-9014df771832.png)

## 3、redolog和binlog的区别？

- redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”，binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”
- redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

## 4、为什么日志需要“两阶段提交”？

**什么是"两阶段提交？"**

写入redolog的状态处于prepare阶段，然后写binlog，写完binlog后提交事务，并将redolog改为commit状态。

**为什么要"两阶段提交？"**

防止写完redolog成功，还未写入binlog的时候宕机了的情况，这样重启后redolog里的数据还存在，可以恢复，但是从库都是拉的binlog，binlog里却丢失数据了。造成主从不一致，所以需要"两阶段提交"。

## 5、MySQL可以恢复到半个月内任意一秒的状态，怎么做的？

首先dba会定期全库备份的，当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，从这个备份恢复到临时库
- 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。
- 这样临时库就跟误删之前的线上库一样了，然后可以把表数据从临时库取出来，按需要恢复到线上库去。

## 6、什么是buffer pool？

增删改操作首先就要对内存的Buffer Pool里的数据执行相应增删改操作，因为直接写盘太慢了，所以有了Buffer Pool。他就是数据库的一个内存组件，里面缓存了磁盘的真实数据，然后我们增删改的时候直接操作Buffer Pool，最后日志文件都写完且commit之后会由线程随机将Buffer Pool里的数据刷到磁盘上。

## 7、buffer pool里包含什么东西？

buffer pool里存的是缓存页（从数据页（磁盘上的）加载进来的）和描述数据。一页16kb，数据页里是一行行数据，描述数据包含比如所属的表空间、数据页的编号、这个缓存页在buffer pool中的地址等描述信息。

## 8、buffer pool中数据页那么多，他怎么知道哪些是空闲的？

> 换种问法：请求进来，发现buffer pool中没有当前请求对应的数据页缓存，buffer pool又那么大，里面无数个数据页，他怎么知道我此次请求的数据放到哪个数据页上？如果放的是一个已存在数据的数据页，那不覆盖了吗？

buffer pool里维护了一份free链表，free链表是个双向链表，里面放的是描述数据，描述数据里面包含页的位置，free链表里的节点都是空闲可用的。所以请求进来后将free链表里最后的node节点移除就好了，就代表此页已经被占用。等释放页的时候在加回free链表中。

## 9、怎么知道我此次请求对应的数据已经在buffer pool里了？

> 如果没在，那么从磁盘上拿走放到缓冲区里缓存，但是他怎么知道我此次请求的数据有没有对应的数据页在缓存区里了呢？

数据库有一个哈希表的数据结构，key是表空间号+数据页号，value是缓存页的地址。每次读取一个数据页到buffer pool之后，都会在这个 哈希表中写入一个key-value，下次再用这个数据页的时候就可以先从哈希表中直接读取出来他是不是已经放到buffer pool里了。

## 10、buffer pool中数据页那么多，他怎么知道哪个页是脏页要刷到磁盘上？

buffer pool里维护了一份flush链表，只要是被修改过的数据都会将其对应的描述数据加入到flush双向链表中，flush链表里的数据都是脏页，都是要被刷到磁盘上去的。刷到磁盘上后将此块描述数据从flush链表中移除，加入到free链表中，让其重新可用 。

## 11、buffer pool满了的话，需要将部分页刷到磁盘，刷哪些？

> 如果Buffer Pool中的缓存页不够了怎么办？也就是说free链表的空闲页不够了怎么办？

那肯定要淘汰一部分数据，然后释放缓存页，加入到free链表中，使其成为空闲页。buffer pool里维护了一份lru双向链表，用于淘汰数据。

### 11.1、淘汰哪些数据？

淘汰哪些缓存命中率很低的数据，也就是不常用的数据页，比如在100次请求中，数据页A被访问或修改了50次，数据页B只被访问或修改了1次，那么没有空闲缓存页的时候肯定是会淘汰B的，让其重新空闲可用。

### 11.2、说说buffer pool里的lru链表的工作原理

首先lru链表分为冷热数据两部分区域。这样做也是为了把性能做到极致。叼的很。

从磁盘加载一个数据页到缓存页的时候，就把这个缓存页的描述数据块放到LRU链表冷数据区头部去，然后在1s之后你修改冷数据区的数据页后才会被挪动到热数据区链表的头部。（根据MySQL的`innodb_old_blocks_times`参数（默认1s）），若修改的是lru链表热数据区的缓存页，则需要判断是不是lru链表热数据区前1/4的缓存页被访问，如果是的话，则不动，如果不是的话（也就是访问的 后面的3/4），则给他挪动到lru热数据区链表头部。这样的话尽可能的减少链表中的节点移动了（因为热数据区操作本来就很频繁），然后若buffer pool的缓存页不够了，则就把lru冷数据区尾部的节点刷到磁盘上且移除lru链表和flush链表且加入到free链表中去。

> MySQL设计者把lru这部分的性能做到了极致，佩服的五体投地！！！
>
> MySQL设计者把lru这部分的性能做到了极致，佩服的五体投地！！！
>
> MySQL设计者把lru这部分的性能做到了极致，佩服的五体投地！！！

**扩展补充**

*为什么搞得这么复杂，不直接：只要有数据的缓存页他都在lru里了，而且最近被修改过的数据缓存页他都会挪到lru链表头部去，当空间不够的时候就把lru尾部的节点刷到磁盘上且移除lru链表和flush链表且加入到free链表中去？*

因为MySQL有预读功能。预读就是当你从磁盘上加载一个数据页到缓存页的时候，他可能连带着把这个数据页相邻的其他页也一起加载到缓存中，比如你查了100w条数据，连着写了5个数据页了，MySQL认为你这次操作这么大，第6个页也需要，所以直接提前给你加载到缓存页了。那么这种情况如果按照上面斜体字的逻辑来看就是第6个页永远没人用，他却跑到了lru链表第6个位置（实际没人访问，顺带着被加载进来的），然后清理的时候从lru尾部开始，不合适呀！所以lru链表有了冷热数据两部分。不得不说MySQL设计者，真TM牛逼。这个冷热让我莫名其妙的想到了并发大师dog 李的读写锁设计，一个int 高低位代表读写两种不同的锁，都是神人！ 

### 11.3、lru链表、flush链表什么时候刷盘？

**LRU链表**

- buffer pool没空闲缓存页的时候
- 有个后台线程每隔一段时间就会把lru冷数据区的尾部一些缓存页刷到磁盘，然后移除lru链表和flush链表且加入到free链表

**flush链表**

- buffer pool没空闲缓存页的时候从lru冷数据区移除数据且移除flush链表的数据
- 有个后台线程每隔一段时间就会把flush链表中的缓存页都刷到磁盘，然后移除lru链表和flush链表且加入到free链表

**总结**

后台线程不停的把flush链表和lru链表冷数据区的缓存页刷到磁盘上去，然后free链表中的缓存页不停的增加。这是个动态过程，并非要free不够了才刷盘释放缓存页。

## 12、什么是脏页？

flush链表里的缓存页都是脏页，也就是说凡是被修改过的且还没刷到磁盘上的缓存页都属于脏页。

## 13、MySQL为什么要有预读功能？

预读就是当你从磁盘上加载一个数据页到缓存页的时候，他可能连带着把这个数据页相邻的其他页页一起加载到缓存中，比如你查了100w条数据，连着写了5个数据页了，MySQL认为你这次操作这么大，第6个页也需要，所以直接提前给你加载到缓存页了。提前预读进行缓存。在某些场景下可以达到性能优化的效果。

## 14、buffer pool优化

增大buffer pool内存，然后设置多个buffer pool，比如 buffer pool设置8GB，实例个数设置为4，相当于每个buffer pool 2GB左右。因为buffer pool默认是1个，操作数据页的时候会上锁，所以可以增加buffer pool个数。

一般建议buffer pool大小设置为MySQL内存的50%~60%。

## 15、redo log长什么样？

- 表空间ID
- 数据页号
- 数据页中的偏移量
- 修改数据长度
- 具体修改的数据

## 16、undo log长什么样？

- undo log的开始位置
- 主键的各列长度和值
- 表的id
- undo log日志编号
- undo log日志类型
- undo log的结束位置

## 17、生产环境下的一次性能抖动

背景：线上运行的服务，出现了一次性能抖动。导致了告警。

经查询发现是如下原因：

平时只需要几百毫秒的语句这一下执行了几秒钟了，经查询发现某个SQL需要查询大量数据（不属于慢SQL的范畴），然后需要将大量的数据缓存到缓存页中去，此时就可能导致内存里大量的脏页需要淘汰出去刷到磁盘上，要不然没空间缓存这批查询的数据到buffer pool中。所以大量的刷盘操作是很慢的，导致了抖动。

补充：

还有一种情况也可能造成性能抖动，就是大量的update/insert/delete语句导致redo log buffer快写满的时候，造成大批量的redo log buffer的数据刷盘操作，这时候你再进行update/insert/delete的时候会发现性能极差，比如单表update/insert/delete发现1s都没完成，这时候可以看下是不是大量的redo log在刷盘。

解决办法：

调整`innodb_io_capacity`参数，这个参数是告诉数据库采用多大的IO速率把缓存页flush到磁盘里，先采取压测看下当前磁盘的io速率支持多少然后针对性调整大小。

调整`innodb_flush_neighbors`参数，这个参数是说flush缓存页到磁盘的时候，可能会控制把缓存页临近的其他缓存页也一起刷到磁盘，但是这样有时候会导致刷磁盘的页太多了，因为临近的页也刷到磁盘来了，所以调整成0。

---
收录时间: 2021-01-05

<Vssue :title="$title" />