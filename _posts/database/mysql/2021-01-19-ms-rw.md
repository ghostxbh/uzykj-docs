---
title: MySQL主从复制和读写分离
date: 2021-01-19
tags:
    - MySQL
    - 主从复制
    - 读写分离
author: 编程界的小学生
location: Gitee
---
# 主从复制和读写分离

## 1、主从复制有什么好处？解决了哪些问题？

- 做备份数据库，主库宕机后，从库可以切换为主库继续工作。
- 提高并发能力

## 2、MySQL主从复制原理的是啥？

- 主库将在每个事务提交之前将变更写入binlog
- 然后从库起一个I/O线程连接到主库，将主库的binlog拷贝到从库本地并写入一个中继日志，relay log，若读取的进度已经跟上了主库，那么就进入睡眠状态并等待主库产生新的事件。
- 接着从库中有一个SQL线程会从relay log里顺序读取日志内容并在从库中执行一遍，从而与主库的数据保持一致

## 3、主从复制半同步复制（semi-sync）什么意思？

> 因为MySQL默认主从方式会造成数据丢失，他是执行完SQL后就提交了事务，此时从库还没拉取变更的binlog，主库挂了，那么从库升级为主库，从库上没有主库刚提交的变更记录，数据丢失。而半同步复制很好的解决主库数据丢失的问题。

主库将变更写入binlog后，就会将数据同步到从库，然后从库同步完binlog且将日志写入自己本地的relay log后会返回给主库一个ack，主库收到ack后才会提交事务。这样完美避免了数据丢失的情况。

## 4、哪些场景可能造成主从延迟？

- 从库所在机器的性能比主库的差很多
- 做了读写分离，从库压力过大导致
- 大事务

> 因为主库上必须等事务执行完成才会写入 binlog，再传给备库。所以，如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。所以不要一次性地用 delete 语句删除太多数据。其实，这就是一个典型的大事务场景。

## 5、如何解决MySQL主从同步的延时问题？

> 也可以被问：读写分离有哪些问题？ 那就是主从同步的延时问题，可能读到旧数据。

- 并行复制

> 提升主从同步效率的一种手段，可以尽量避免主从同步的延迟问题，从库开启多个线程并行去读取relay log中不同库的日志，然后并行重放不同库的 日志，着是库级别的并行。MySQL5.7支持的。

- 强制走主库方案

> 将请求分成两类：允许读到旧数据的和不允许读到旧数据的，把允许读到的那些场景走读库，不允许的那些SQL强制去读主库。

- 判断主备无延迟方案

> 1.等主库位点方案
>
> 2.GTID 方案

## 6、并行复制是什么意思？

提升主从同步效率的一种手段，可以尽量避免主从同步的延迟问题，从库开启多个线程并行去读取relay log中不同库的日志，然后并行重放不同库的 日志，着是库级别的并行。MySQL5.7支持的。

## 7、介绍下主从复制GTID的方式？

以前 MySQL 的主从复制是基于复制点的，slave 从 master 二进制日志的某个位置开始复制

有了 GTID 之后，就多了一种复制方式，MySQL 在每个事务操作时都会分配一个全局唯一的ID，slave 就可以基于这个ID进行复制，只要是自己没有复制过的事务，就拿过来进行复制，可以不用关心具体的复制位置了

优点：

- 可以更方便的故障转移，出现问题时，多个slave不用根据新master的二进制偏移量来同步了

- 主从配置更简单

## 8、如何解决互为主备后的循环复制问题？

互为主备，也就是A和B两个节点互为主从，A既是B的主节点又是B的从节点，反过来B既是A的主节点又是A的从节点。也是双M架构。那么就产生个问题：

A节点变更了一条记录将binlog同步给了B节点，B节点执行完这条语句后也产生了一个binlog又将日志传给A，这不是死循环吗？这就是互为主备的循环复制问题。

我们可以用下面的逻辑，来解决两个节点间的循环复制的问题：

- 规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系
- 一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog
- 每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。

按照这个逻辑，如果我们设置了双 M 结构，日志的执行流就会变成这样：

- 从节点 A 更新的事务，binlog 里面记的都是 A 的 server id
- 传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id
- 再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。

但依然有风险，如下：

- 在一个主库更新事务后，用命令 set global server_id=x 修改了 server_id。等日志再传回来的时候，发现 server_id 跟自己的 server_id 不同，就只能执行了。

## 9、为什么要做读写分离？

- 分摊服务器压力，提高机器的系统处理效率。读写分离适用于读远比写多的场景

- 增加冗余，提高服务可用性，当一台数据库服务器宕机后可以调整另外一台从库以最快速度恢复服务

## 10、如何实现MySQL的读写分离？

- mycat中间件
- sharding-jdbc这种在代码业务层自己控制

---
收录时间: 2021-01-19

<Vssue :title="$title" />