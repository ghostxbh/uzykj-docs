# 持久化

## 1、什么是持久化？Redis为什么需要持久化？

持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

## 2、Redis有哪几种持久化方式？优缺点是什么？

rdb（默认） 和aof两种。

rdb优点：

- 二进制存储节省空间，只有一个dump.rdb文件。
- 灾难恢复较快。
- 性能最大化（主进程处理命令的效率，而不是持久化的效率），采取的是fork()+copyonwrite技术。

rdb缺点：

- 安全性相对较低，因为rdb是每隔一段时间进行持久化，数据丢失率较高。
- 持久化速度相对aof较低，因为aof直接append追加，rdb是全量。

aof优点：

- 数据安全，可以配置always，也就是每进行一次命令操作就记录到aof文件中一次。
- 持久化速度较快，每次都只是追加一个语句到文件。
- 带rewrite机制。

aof缺点：

- AOF 文件比 RDB 文件大，所以灾难性恢复速度慢。
- 会对主进程对外提供请求的效率造成影响，接收请求、处理请求、写aof文件这三步是串行原子执行的。而非异步多线程执行的。Redis单线程！

## 3、两种持久化方式如何做选择？

- 如果数据非常敏感，尽量做到不丢失，那么选择aof，反之rdb。
- 如果追求容灾恢复速度，那么建议rdb，因为他是二进制的，文件很小，恢复速度快。
- 如果追求读写速度，那么建议rdb，因为他是fork出来子进程配合copyonwrite技术来持久化，不会影响主进程的读写。
- Redis4.0后支持混合持久化，也就是rdb+aof，建议开启。

## 4、RDB持久化的原理是怎样的？

fork子进程+copyonwrite技术。

### 4.1、什么是fork？

fork()是unix和linux这种操作系统的一个api，而不是Redis的api。fork()用于创建一个子进程，注意是子进程，不是子线程。fork()出来的进程共享其父类的内存数据。仅仅是共享fork()出子进程的那一刻的内存数据，后期主进程修改数据对子进程不可见，同理，子进程修改的数据对主进程也不可见。比如：A进程fork()了一个子进程B，那么A进程就称之为主进程，这时候主进程A和子进程B所指向的内存空间是同一个，所以他们的数据一致。但是A修改了内存上的一条数据，这时候B是看不到的，A新增一条数据，删除一条数据，B都是看不到的。而且子进程B出问题了，对我主进程A完全没影响，我依然可以对外提供服务，但是主进程挂了，子进程也必须跟随一起挂。这一点有点像守护线程的概念。Redis正是巧妙的运用了fork()这个牛逼的api来完成RDB的持久化操作。

#### 4.1.1、Redis中的fork()

Redis巧妙的运用了fork()。当bgsave执行时，Redis主进程会判断当前是否有fork()出来的子进程，若有则忽略，若没有则会fork()出一个子进程来执行rdb文件持久化的工作，子进程与Redis主进程共享同一份内存空间，所以子进程可以搞他的rdb文件持久化工作，主进程又能继续他的对外提供服务，二者互不影响。我们说了他们之后的修改内存数据对彼此不可见，但是明明指向的都是同一块内存空间，这是咋搞得？肯定不可能是fork()出来子进程后顺带复制了一份数据出来，如果是这样的话比如我有4g内存，那么其实最大有限空间是2g，我要给rdb留出一半空间来，扯淡一样！那他咋做的？采取了copyonwrite技术。

### 4.2、什么是copyonwrite？

主进程fork()子进程之后，内核把主进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向主进程。这也就是共享了主进程的内存，当其中某个进程写内存时(这里肯定是主进程写，因为子进程只负责rdb文件持久化工作，不参与客户端的请求)，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入内核的一个中断例程。中断例程中，内核就会把触发的异常的页复制一份（这里仅仅复制异常页，也就是所修改的那个数据页，而不是内存中的全部数据），于是主子进程各自持有独立的一份。

*数据修改之前的样子*

![1](http://file.uzykj.com/redis_1.jpg)

*数据修改之后的样子*

![1](http://file.uzykj.com/redis_2.jpg)

其实就是更改数据的之前进行copy一份更改数据的数据页出来，比如主进程收到了`set k 1`请求(之前k的值是2)，然后这同时又有子进程在rdb持久化，那么主进程就会把k这个key的数据页拷贝一份，并且主进程中k这个指针指向新拷贝出来的数据页地址上，然后进行更改值为1的操作，这个主进程k元素地址引用的新拷贝出来的地址，而子进程引用的内存数据k还是修改之前的。

#### 4.2.1、一句话总结copyonwrite

copyonwritefork()出来的子进程共享主进程的物理空间，当主子进程有内存写入操作时，read-only内存页发生中断，将触发的异常的内存页复制一份(其余的页还是共享主进程的)。

### 4.3、为什么要用copyonwrite？

1.假设是全量复制，那么内存空间直接减半，浪费资源不说，数据量10g，全量复制这10g的时间也够长的。这谁顶得住？

2.如果不全量复制，会是怎样？相当于我一边复制，你一边写数据，看着貌似问题不大，其实不然。比如现在Redis里有k1的值是1，k2的值是2，比如bgsave了，这时候rdb写入了k1的值，在写k2的值之前时，有个客户端请求

```redis
set k1 11 
set k2 22
```

那么持久化进去的是k2 22，但是k1的值还是1，而不是最新的11，所以会造成数据问题，所以采取了copyonwrite技术来保证触发bgsave请求的时候无论你怎么更改，都对我rdb文件的数据持久化不会造成任何影响。

## 5、AOF持久化的原理是怎样的？

就是每次都在aof文件后面追加命令。他与主进程收到请求、**处理请求是串行化的，而非异步并行的**。图示如下：

![3](http://file.uzykj.com/redis_3.png)

所以aof的频率高的话绝逼会对Redis带来性能影响，因为每次都是刷盘操作。跟mysql一样了。Redis每次都是先将命令放到缓冲区，然后根据具体策略（每秒/每条指令/缓冲区满）进行刷盘操作。如果配置的always，那么就是典型阻塞，如果是sec，每秒的话，那么会开一个同步线程去每秒进行刷盘操作，对主线程影响稍小。

### 5.1、AOF有哪几种刷盘策略？

其实Redis每次在写入AOF缓冲区之前，他都会调用flushAppendOnlyFile()，判断是否需要将AOF缓冲区的内容写入和同步到AOF文件中。这个决策是由配置文件的三个策略来控制的

- always
- everysec
- no

## 6、RDB和AOF哪个快？

**1、分析**

这道题不严谨，因为不知道他问的是持久化过程哪个快还是说Redis主进程对外提供请求哪个快？（也就是说哪个持久化方式会对主进程影响较大）

**2、持久化过程哪个快**

那肯定AOF，因为AOF每次只追加命令，而RDB每次都是全量覆盖。

**3、哪个持久化方式会对主进程影响较大**

那肯定是AOF效率低，因为AOF是串行的，相当于每次处理完命令都要同步的写入磁盘（当然也看具体策略），而bgsave模式的RDB则是开启子进程并行的处理这件事，不影响主进程对外提供请求，即使AOF策略开到最容易丢失数据的那种，那也是不定期磁盘操作，这是毫秒级别的。而RDB持久化即使发生CopyOnWrite也只是寻址操作，纳秒级别的。

## 7、能同时存在几个fork？为什么？

只能同时存在一个，原因如下：

- bgsave命令执行期间，client发送的save/bgsave命令会被服务器拒绝，这么做是因为如果产生多个子进程同时进行rdb持久化的工作的话会产生竞争条件，造成数据问题已经服务器压力也会某些条件下过大。
- bgrewriteaof和bgsave能不能同时执行？

> 不能！
>
> 1.如果bgsave正在执行，那么client发送的bgrewriteaof命令会被推迟到bgsave结束后才得到执行。
> 2.如果bgrewriteaof正在执行，那么client发送的bgsave命令将会被服务器拒绝

## 8、RBD和AOF的文件格式有什么区别？

RDB：

- 以.rdb后缀结尾
- 以REDIS为魔数的二进制

AOF：

- 以.aof后缀结尾
- 记录具体操作的命令
- rewrite后也变成二进制

## 9、聊聊AOF的rewrite机制？

### 9.1、为什么要rewrite？

比如我有业务很简单，就来回delete set 同一个key。就这个业务运行了10年，那么aof文件将记录无数个delete k1， set k1 xxx。其实都是重复的，但是我aof每次都追加，文件变成了1T大小。这时候Redis宕机了，要恢复，你想想1TB大小的aof文件去恢复，累死了。最主要的是1TB大小只记录了两个命令，所以压缩其实就是来处理这件事的。

### 9.2、rewrite后的数据长什么样？

- 4.0版本之前

> Redis4.0之前就是将aof文件中重复的命令给去掉。保留最新的命令。进而减少aof文件大小。

- 4.0版本以及之后

> 4.0之前的做法效率很是低下，需要逐条命令对比。4.0开始的rewrite支持**混合模式**(也是就是rdb和aof一起用)，直接将rdb持久化的方式来操作将二进制内容覆盖到aof文件中（rdb是二进制，所以很小），然后再有写入的话还是继续append追加到文件原始命令，等下次文件过大的时候再次rewrite（还是按照rdb持久化的方式将内容覆盖到aof中）。但是这种模式也是配置的，默认是开，也可以关闭。

### 9.3、什么时候会触发rewrite？

- 手动触发

> 执行bgrewriteaof命令。

- 自动触发

> 通过以下两个配置协作触发
>
> - auto-aof-rewrite-min-size
>
> > AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写,4.0默认配置64mb。
>
> - auto-aof-rewrite-percentage
>
> > 当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，如100代表当前AOF文件是上次重写的两倍时候才重写。

### 9.4、rewrite原理

![4](http://file.uzykj.com/redis_4.png)

- aof_rewrite_buf：rewrite(重写)缓冲区、aof_buf：写命令存放的缓冲区
- 开始bgrewriteaof的时候，判断当前有没有bgsave/bgrewriteaof在执行，若有，则不执行
- 主进程fork()出子进程，在执行fork()这个方法的时候是阻塞的，子进程创建完毕后就不阻塞了
- 主进程fork完子进程后，主进程能继续接收客户端的请求，所有写命令依然是写入AOF文件缓冲区并根据配置文件的策略同步到磁盘的。
- 因为fork的子进程仅仅共享主进程fork()时的内存，后期主进程在更改内存数据，子进程是不可见的。因此Redis采取重写缓冲区（aof_rewite_buf）保存fork之后的客户端请求。防止新AOF文件生成期间丢失主进程执行的新命令所生成的数据。所以此时客户端的写请求不仅仅写入原来的aof_buf缓冲区，还写入了重写缓冲区。这就是我为什么用深蓝色的框给他两框到一起的原因。
- 子进程通过内存快照的形式，开始生成新的aof文件。
- 新aof文件生成完后，子进程向主进程发信号。
- 主进程收到信号后，会把重写缓冲区(aof_rewite_buf)中的数据写入到新的AOF文件（主要是避免这部分数据丢失）
- 使用新的AOF文件覆盖旧的AOF文件，且标记AOF重写完成。

## 10、聊聊Redis的混合持久化方式？

### 10.1、优点

混合持久化结合了RDB持久化 和 AOF 持久化的优点,采取了rdb的文件小易于灾难恢复，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。

### 10.2、缺点

兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，需要专业的工具来阅读，因为是二进制，所以阅读性较差。

### 10.3、总结

Redis4.0以及以后新增的内容，很强大。默认开启，也建议开启。但具体还要看业务，比如业务就允许数据丢失，那直接RDB就完事了，不需要开AOF，这样效率还高。如果一点数据都不允许丢失，那只能RDB+always策略的AOF，换言之，不管怎样，都建议开启RDB，RDB可以应对灾难性快速恢复。混合持久化也不用过于担心文件大小问题，4.0开始的rewrite支持混合模式直接按rdb持久化的方式来操作将二进制内容覆盖到aof文件中（rdb是二进制，所以很小），然后再有写入的话还是继续append追加到文件原始命令，等下次文件过大的时候再次rewrite（还是按照rdb持久化的方式将内容覆盖到aof中），堪称完美！

### 10.4、数据恢复

会优先看是否存在aof文件，若存在则先按照aof文件恢复，因为aof毕竟比rdb全。若aof不存在，则才会查找rdb是否存在。这是默认的机制。毕竟aof文件也rewrite成rdb二进制格式，文件小，易于回复。所以redis会优先采取aof。

## 11、如何手动进行rdb持久化？

- save

> 同步、阻塞。
>
> 致命的问题，持久化的时候redis服务阻塞（准确的说会阻塞当前执行save命令的线程，但是redis是单线程的，所以整个服务会阻塞），不能继对外提供请求，GG！数据量小的话肯定影响不大，数据量大呢？每次复制需要1小时，那就相当于停机一小时。

- bgsave

> 异步、非阻塞。
>
> 采取fork() + copyonwrite的方式，他可以一边进行持久化，一边对外提供读写服务，互不影响，新写的数据对我持久化不会造成数据影响，你持久化的过程中报错或者耗时太久都对我当前对外提供请求的服务不会产生任何影响。持久化完会将新的rdb文件覆盖之前的。


---
收录时间: 2021/01/11

<Vssue :title="$title" />