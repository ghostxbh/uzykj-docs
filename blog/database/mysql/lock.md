# 锁

## 1、锁都有哪几种？什么意思？

- 全局锁

> 对整个数据库实例加锁，开启全局锁后整个数据库的更新语句，修改表结构语句都会被阻塞，多用于全库逻辑备份的时候，就需要开启全局锁让整个库处于只读状态，防止数据不一致的情况。

- 表锁

> 对整张表进行加锁，表锁被大部分的mysql引擎支持，MyISAM和InnoDB都支持表级锁。

- 行锁

> 只锁某一行，比如id=3的这行数据，其他的比如id=4的数据不会被锁。InnoDB支持。行级锁分为共享锁 和 排他锁。

- 共享锁

> `select ... lock in share mode;`
>
> 就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。

- 排他锁

> `select ... for update;`
>
> 就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁。包括读也不行。

- 间隙锁

> 作用于非唯一索引上，当我们使用范围条件查询而不是等值条件查询的时候，InnoDB就会给符合条件的范围索引加锁，在条件范围内并不存的记录就叫做"间隙（GAP）"，主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。
>
> 如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。
>
> 比如有数据：1，2，3，4，5，6，7，8
>
> `SELECT * FROM t WHERE key > 4 AND key < 7;`
>
> 那么就会给4-7这个范围加间隙锁，意味着不能在这段修改数据，否则造成幻读了。

- 死锁

> 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。比如
>
> |                    session1                    |              session2              |
> | :--------------------------------------------: | :--------------------------------: |
> | begin;<br />update t set name='xx' where id=1; |               begin                |
> |                                                | update t set name='xx' where id=2; |
> |       update t set name='xx' where id=2;       |                                    |
> |                   等待.....                    | update t set name='xx' where id=1; |
> |                   等待.....                    |             等待.....              |

## 2、说说事务隔离级别与锁的关系

- 读未提交：不需要加共享锁，这样就不会跟被修改的数据的排他锁冲突。
- 读已提交：需要加共享锁，但是语句执行完后要释放锁。
- 可重复读：读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。
- 串行化：该级别锁定整个范围的键，并一直持有锁，直到事务完成。

## 3、什么是死锁

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。死锁在InnoDB中才会出现死锁，MyISAM是不会出现死锁，因为MyISAM支持的是表锁，一次性获取了所有得锁，其它的线程只能排队等候。

## 4、怎么解决死锁？

- 等待事务超时，主动回滚。

- 进行死锁检查，主动回滚某条事务，让别的事务能继续走下去。

下面提供一种方法，解决死锁的状态:

```mysql
-- 查看正在被锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
```

下面提供三种一定概率避免死锁的方法：

- 如果不同程序会并发存取多个表，尽量约定以**相同的顺序**访问表，可以大大降低死锁概率。

- 在同一个事务中尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。

- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

## 5、死锁出现的案列

批量入库，存在则更新不存在则插入，`insert into t1(xxx,xxx) on duplicate key update name = 'xxx';`，具体原因可以自行Google搜下：

`insert into … on duplicate key update 死锁`

---
收录时间: 2021/01/05

<Vssue :title="$title" />